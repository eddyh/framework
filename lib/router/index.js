"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _route = require("./route");

var _route2 = _interopRequireDefault(_route);

var _tree = require("./tree");

var _tree2 = _interopRequireDefault(_tree);

var _node = require("./node");

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let Router = class Router {

  constructor() {
    this.tree = new _tree2.default();

    Object.freeze(this);
  }

  define(method, pattern, handler = null) {
    const route = _route2.default.parse(method, pattern);
    define(this.tree.insert(route), route, handler);
  }

  mount(pattern, router) {
    for (const [{ handler }, path] of router.tree.traverse()) {
      const route = _route2.default.create(path).prefix(pattern);
      define(this.tree.insert(route), route, handler);
    }
  }

  match(method, url) {
    const { node, params } = this.tree.match(parse(method, url));
    if (!node) return {};
    return { handler: node.handler, params };
  }

  get routes() {
    const routes = new Set();
    for (const [, path] of this.tree.traverse()) {
      routes.add(_route2.default.create(path));
    }
    return Array.from(routes);
  }

  get handlers() {
    const handlers = new Set();
    for (const [node] of this.tree.traverse()) {
      if (node.handler) handlers.add(node.handler);
    }
    return Array.from(handlers);
  }

  inspect() {
    const routes = this.routes.map(route => route.inspect());
    return "[ " + routes.join(",\n  ") + " ]";
  }
};
exports.default = Router;


function define(node, route, handler) {
  if (node.leaf) throw new _route.RouteError(route, "already exists");
  node.leaf = true;
  node.handler = handler;
}

function parse(method, url) {
  /* Remove leading slash. */
  if (url[0] === "/") url = url.slice(1);

  /* Remove query string. */
  url = url.split("?").shift();

  /* Split url into path segments. */
  const parts = url.split("/").filter(part => part !== "");
  return [method.toUpperCase()].concat(parts);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yb3V0ZXIvaW5kZXguanMiXSwibmFtZXMiOlsiUm91dGVyIiwiY29uc3RydWN0b3IiLCJ0cmVlIiwiVHJlZSIsIk9iamVjdCIsImZyZWV6ZSIsImRlZmluZSIsIm1ldGhvZCIsInBhdHRlcm4iLCJoYW5kbGVyIiwicm91dGUiLCJSb3V0ZSIsInBhcnNlIiwiaW5zZXJ0IiwibW91bnQiLCJyb3V0ZXIiLCJwYXRoIiwidHJhdmVyc2UiLCJjcmVhdGUiLCJwcmVmaXgiLCJtYXRjaCIsInVybCIsIm5vZGUiLCJwYXJhbXMiLCJyb3V0ZXMiLCJTZXQiLCJhZGQiLCJBcnJheSIsImZyb20iLCJoYW5kbGVycyIsImluc3BlY3QiLCJtYXAiLCJqb2luIiwibGVhZiIsIlJvdXRlRXJyb3IiLCJzbGljZSIsInNwbGl0Iiwic2hpZnQiLCJwYXJ0cyIsImZpbHRlciIsInBhcnQiLCJ0b1VwcGVyQ2FzZSIsImNvbmNhdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0lBRXFCQSxNLEdBQU4sTUFBTUEsTUFBTixDQUFhOztBQUcxQkMsZ0JBQWM7QUFBQSxTQUZkQyxJQUVjLEdBRkQsSUFBSUMsY0FBSixFQUVDOztBQUNaQyxXQUFPQyxNQUFQLENBQWMsSUFBZDtBQUNEOztBQUVEQyxTQUFPQyxNQUFQLEVBQXVCQyxPQUF2QixFQUF3Q0MsVUFBbUIsSUFBM0QsRUFBaUU7QUFDL0QsVUFBTUMsUUFBUUMsZ0JBQU1DLEtBQU4sQ0FBWUwsTUFBWixFQUFvQkMsT0FBcEIsQ0FBZDtBQUNBRixXQUFPLEtBQUtKLElBQUwsQ0FBVVcsTUFBVixDQUFpQkgsS0FBakIsQ0FBUCxFQUFnQ0EsS0FBaEMsRUFBdUNELE9BQXZDO0FBQ0Q7O0FBRURLLFFBQU1OLE9BQU4sRUFBdUJPLE1BQXZCLEVBQXVDO0FBQ3JDLFNBQUssTUFBTSxDQUFDLEVBQUNOLE9BQUQsRUFBRCxFQUFZTyxJQUFaLENBQVgsSUFBZ0NELE9BQU9iLElBQVAsQ0FBWWUsUUFBWixFQUFoQyxFQUF3RDtBQUN0RCxZQUFNUCxRQUFRQyxnQkFBTU8sTUFBTixDQUFhRixJQUFiLEVBQW1CRyxNQUFuQixDQUEwQlgsT0FBMUIsQ0FBZDtBQUNBRixhQUFPLEtBQUtKLElBQUwsQ0FBVVcsTUFBVixDQUFpQkgsS0FBakIsQ0FBUCxFQUFnQ0EsS0FBaEMsRUFBdUNELE9BQXZDO0FBQ0Q7QUFDRjs7QUFFRFcsUUFBTWIsTUFBTixFQUFzQmMsR0FBdEIsRUFBeUU7QUFDdkUsVUFBTSxFQUFDQyxJQUFELEVBQU9DLE1BQVAsS0FBaUIsS0FBS3JCLElBQUwsQ0FBVWtCLEtBQVYsQ0FBZ0JSLE1BQU1MLE1BQU4sRUFBY2MsR0FBZCxDQUFoQixDQUF2QjtBQUNBLFFBQUksQ0FBQ0MsSUFBTCxFQUFXLE9BQU8sRUFBUDtBQUNYLFdBQU8sRUFBQ2IsU0FBU2EsS0FBS2IsT0FBZixFQUF3QmMsTUFBeEIsRUFBUDtBQUNEOztBQUVELE1BQUlDLE1BQUosR0FBc0I7QUFDcEIsVUFBTUEsU0FBUyxJQUFJQyxHQUFKLEVBQWY7QUFDQSxTQUFLLE1BQU0sR0FBSVQsSUFBSixDQUFYLElBQXdCLEtBQUtkLElBQUwsQ0FBVWUsUUFBVixFQUF4QixFQUE4QztBQUM1Q08sYUFBT0UsR0FBUCxDQUFXZixnQkFBTU8sTUFBTixDQUFhRixJQUFiLENBQVg7QUFDRDtBQUNELFdBQU9XLE1BQU1DLElBQU4sQ0FBV0osTUFBWCxDQUFQO0FBQ0Q7O0FBRUQsTUFBSUssUUFBSixHQUF5QjtBQUN2QixVQUFNQSxXQUFXLElBQUlKLEdBQUosRUFBakI7QUFDQSxTQUFLLE1BQU0sQ0FBQ0gsSUFBRCxDQUFYLElBQXFCLEtBQUtwQixJQUFMLENBQVVlLFFBQVYsRUFBckIsRUFBMkM7QUFDekMsVUFBSUssS0FBS2IsT0FBVCxFQUFrQm9CLFNBQVNILEdBQVQsQ0FBYUosS0FBS2IsT0FBbEI7QUFDbkI7QUFDRCxXQUFPa0IsTUFBTUMsSUFBTixDQUFXQyxRQUFYLENBQVA7QUFDRDs7QUFFREMsWUFBa0I7QUFDaEIsVUFBTU4sU0FBUyxLQUFLQSxNQUFMLENBQVlPLEdBQVosQ0FBZ0JyQixTQUFTQSxNQUFNb0IsT0FBTixFQUF6QixDQUFmO0FBQ0EsV0FBTyxPQUFPTixPQUFPUSxJQUFQLENBQVksT0FBWixDQUFQLEdBQThCLElBQXJDO0FBQ0Q7QUE1Q3lCLEM7a0JBQVBoQyxNOzs7QUErQ3JCLFNBQVNNLE1BQVQsQ0FBZ0JnQixJQUFoQixFQUE0QlosS0FBNUIsRUFBMENELE9BQTFDLEVBQTREO0FBQzFELE1BQUlhLEtBQUtXLElBQVQsRUFBZSxNQUFNLElBQUlDLGlCQUFKLENBQWV4QixLQUFmLEVBQXNCLGdCQUF0QixDQUFOO0FBQ2ZZLE9BQUtXLElBQUwsR0FBWSxJQUFaO0FBQ0FYLE9BQUtiLE9BQUwsR0FBZUEsT0FBZjtBQUNEOztBQUVELFNBQVNHLEtBQVQsQ0FBZUwsTUFBZixFQUErQmMsR0FBL0IsRUFBNEM7QUFDMUM7QUFDQSxNQUFJQSxJQUFJLENBQUosTUFBVyxHQUFmLEVBQW9CQSxNQUFNQSxJQUFJYyxLQUFKLENBQVUsQ0FBVixDQUFOOztBQUVwQjtBQUNBZCxRQUFNQSxJQUFJZSxLQUFKLENBQVUsR0FBVixFQUFlQyxLQUFmLEVBQU47O0FBRUE7QUFDQSxRQUFNQyxRQUFRakIsSUFBSWUsS0FBSixDQUFVLEdBQVYsRUFBZUcsTUFBZixDQUFzQkMsUUFBUUEsU0FBUyxFQUF2QyxDQUFkO0FBQ0EsU0FBTyxDQUFDakMsT0FBT2tDLFdBQVAsRUFBRCxFQUF1QkMsTUFBdkIsQ0FBOEJKLEtBQTlCLENBQVA7QUFDRCIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5pbXBvcnQgUm91dGUsIHtSb3V0ZUVycm9yfSBmcm9tIFwiLi9yb3V0ZVwiXG5pbXBvcnQgVHJlZSBmcm9tIFwiLi90cmVlXCJcbmltcG9ydCBOb2RlIGZyb20gXCIuL25vZGVcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIge1xuICB0cmVlOiBUcmVlID0gbmV3IFRyZWVcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpXG4gIH1cblxuICBkZWZpbmUobWV0aG9kOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZywgaGFuZGxlcjogP09iamVjdCA9IG51bGwpIHtcbiAgICBjb25zdCByb3V0ZSA9IFJvdXRlLnBhcnNlKG1ldGhvZCwgcGF0dGVybilcbiAgICBkZWZpbmUodGhpcy50cmVlLmluc2VydChyb3V0ZSksIHJvdXRlLCBoYW5kbGVyKVxuICB9XG5cbiAgbW91bnQocGF0dGVybjogc3RyaW5nLCByb3V0ZXI6IFJvdXRlcikge1xuICAgIGZvciAoY29uc3QgW3toYW5kbGVyfSwgcGF0aF0gb2Ygcm91dGVyLnRyZWUudHJhdmVyc2UoKSkge1xuICAgICAgY29uc3Qgcm91dGUgPSBSb3V0ZS5jcmVhdGUocGF0aCkucHJlZml4KHBhdHRlcm4pXG4gICAgICBkZWZpbmUodGhpcy50cmVlLmluc2VydChyb3V0ZSksIHJvdXRlLCBoYW5kbGVyKVxuICAgIH1cbiAgfVxuXG4gIG1hdGNoKG1ldGhvZDogc3RyaW5nLCB1cmw6IHN0cmluZyk6IHtoYW5kbGVyPzogP09iamVjdCwgcGFyYW1zPzogT2JqZWN0fSB7XG4gICAgY29uc3Qge25vZGUsIHBhcmFtc30gPSB0aGlzLnRyZWUubWF0Y2gocGFyc2UobWV0aG9kLCB1cmwpKVxuICAgIGlmICghbm9kZSkgcmV0dXJuIHt9XG4gICAgcmV0dXJuIHtoYW5kbGVyOiBub2RlLmhhbmRsZXIsIHBhcmFtc31cbiAgfVxuXG4gIGdldCByb3V0ZXMoKTogUm91dGVbXSB7XG4gICAgY29uc3Qgcm91dGVzID0gbmV3IFNldFxuICAgIGZvciAoY29uc3QgWyAsIHBhdGhdIG9mIHRoaXMudHJlZS50cmF2ZXJzZSgpKSB7XG4gICAgICByb3V0ZXMuYWRkKFJvdXRlLmNyZWF0ZShwYXRoKSlcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocm91dGVzKVxuICB9XG5cbiAgZ2V0IGhhbmRsZXJzKCk6IE9iamVjdFtdIHtcbiAgICBjb25zdCBoYW5kbGVycyA9IG5ldyBTZXRcbiAgICBmb3IgKGNvbnN0IFtub2RlXSBvZiB0aGlzLnRyZWUudHJhdmVyc2UoKSkge1xuICAgICAgaWYgKG5vZGUuaGFuZGxlcikgaGFuZGxlcnMuYWRkKG5vZGUuaGFuZGxlcilcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaGFuZGxlcnMpXG4gIH1cblxuICBpbnNwZWN0KCk6IHN0cmluZyB7XG4gICAgY29uc3Qgcm91dGVzID0gdGhpcy5yb3V0ZXMubWFwKHJvdXRlID0+IHJvdXRlLmluc3BlY3QoKSlcbiAgICByZXR1cm4gXCJbIFwiICsgcm91dGVzLmpvaW4oXCIsXFxuICBcIikgKyBcIiBdXCJcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmUobm9kZTogTm9kZSwgcm91dGU6IFJvdXRlLCBoYW5kbGVyOiA/T2JqZWN0KSB7XG4gIGlmIChub2RlLmxlYWYpIHRocm93IG5ldyBSb3V0ZUVycm9yKHJvdXRlLCBcImFscmVhZHkgZXhpc3RzXCIpXG4gIG5vZGUubGVhZiA9IHRydWVcbiAgbm9kZS5oYW5kbGVyID0gaGFuZGxlclxufVxuXG5mdW5jdGlvbiBwYXJzZShtZXRob2Q6IHN0cmluZywgdXJsOiBzdHJpbmcpIHtcbiAgLyogUmVtb3ZlIGxlYWRpbmcgc2xhc2guICovXG4gIGlmICh1cmxbMF0gPT09IFwiL1wiKSB1cmwgPSB1cmwuc2xpY2UoMSlcblxuICAvKiBSZW1vdmUgcXVlcnkgc3RyaW5nLiAqL1xuICB1cmwgPSB1cmwuc3BsaXQoXCI/XCIpLnNoaWZ0KClcblxuICAvKiBTcGxpdCB1cmwgaW50byBwYXRoIHNlZ21lbnRzLiAqL1xuICBjb25zdCBwYXJ0cyA9IHVybC5zcGxpdChcIi9cIikuZmlsdGVyKHBhcnQgPT4gcGFydCAhPT0gXCJcIilcbiAgcmV0dXJuIFttZXRob2QudG9VcHBlckNhc2UoKV0uY29uY2F0KHBhcnRzKVxufVxuIl19