"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _route = require("./route");

var _route2 = _interopRequireDefault(_route);

var _tree = require("./tree");

var _tree2 = _interopRequireDefault(_tree);

var _node = require("./node");

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let Router = class Router {

  constructor() {
    this.tree = new _tree2.default();

    Object.freeze(this);
  }

  define(method, pattern, handler = null) {
    const route = _route2.default.parse(method, pattern);
    define(this.tree.insert(route), route, handler);
  }

  mount(pattern, router) {
    for (const [{ handler }, path] of router.tree.traverse()) {
      const route = _route2.default.create(path).prefix(pattern);
      define(this.tree.insert(route), route, handler);
    }
  }

  match(method, url) {
    const { node, params } = this.tree.match(parse(method, url));
    if (!node) return {};
    return { handler: node.handler, params };
  }

  get routes() {
    const routes = new Set();
    for (const [, path] of this.tree.traverse()) {
      routes.add(_route2.default.create(path));
    }
    return Array.from(routes);
  }

  get handlers() {
    const handlers = new Set();
    for (const [node] of this.tree.traverse()) {
      if (node.handler) handlers.add(node.handler);
    }
    return Array.from(handlers);
  }

  inspect() {
    const routes = this.routes.map(route => route.inspect());
    return "[ " + routes.join(",\n  ") + " ]";
  }
};
exports.default = Router;


function define(node, route, handler) {
  if (node.leaf) throw new _route.RouteError(route, "already exists");
  node.leaf = true;
  node.handler = handler;
}

function parse(method, url) {
  /* Remove leading slash. */
  if (url[0] === "/") url = url.slice(1);

  /* Remove query string. */
  url = url.split("?").shift();

  /* Split url into path segments. */
  const parts = url.split("/").filter(part => part !== "");
  return [method.toUpperCase()].concat(parts);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yb3V0ZXIvaW5kZXguanMiXSwibmFtZXMiOlsiUm91dGVyIiwiY29uc3RydWN0b3IiLCJ0cmVlIiwiT2JqZWN0IiwiZnJlZXplIiwiZGVmaW5lIiwibWV0aG9kIiwicGF0dGVybiIsImhhbmRsZXIiLCJyb3V0ZSIsInBhcnNlIiwiaW5zZXJ0IiwibW91bnQiLCJyb3V0ZXIiLCJwYXRoIiwidHJhdmVyc2UiLCJjcmVhdGUiLCJwcmVmaXgiLCJtYXRjaCIsInVybCIsIm5vZGUiLCJwYXJhbXMiLCJyb3V0ZXMiLCJTZXQiLCJhZGQiLCJBcnJheSIsImZyb20iLCJoYW5kbGVycyIsImluc3BlY3QiLCJtYXAiLCJqb2luIiwibGVhZiIsInNsaWNlIiwic3BsaXQiLCJzaGlmdCIsInBhcnRzIiwiZmlsdGVyIiwicGFydCIsInRvVXBwZXJDYXNlIiwiY29uY2F0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7SUFFcUJBLE0sR0FBTixNQUFNQSxNQUFOLENBQWE7O0FBRzFCQyxnQkFBYztBQUFBLFNBRmRDLElBRWMsR0FGRCxvQkFFQzs7QUFDWkMsV0FBT0MsTUFBUCxDQUFjLElBQWQ7QUFDRDs7QUFFREMsU0FBT0MsTUFBUCxFQUF1QkMsT0FBdkIsRUFBd0NDLFVBQW1CLElBQTNELEVBQWlFO0FBQy9ELFVBQU1DLFFBQVEsZ0JBQU1DLEtBQU4sQ0FBWUosTUFBWixFQUFvQkMsT0FBcEIsQ0FBZDtBQUNBRixXQUFPLEtBQUtILElBQUwsQ0FBVVMsTUFBVixDQUFpQkYsS0FBakIsQ0FBUCxFQUFnQ0EsS0FBaEMsRUFBdUNELE9BQXZDO0FBQ0Q7O0FBRURJLFFBQU1MLE9BQU4sRUFBdUJNLE1BQXZCLEVBQXVDO0FBQ3JDLFNBQUssTUFBTSxDQUFDLEVBQUNMLE9BQUQsRUFBRCxFQUFZTSxJQUFaLENBQVgsSUFBZ0NELE9BQU9YLElBQVAsQ0FBWWEsUUFBWixFQUFoQyxFQUF3RDtBQUN0RCxZQUFNTixRQUFRLGdCQUFNTyxNQUFOLENBQWFGLElBQWIsRUFBbUJHLE1BQW5CLENBQTBCVixPQUExQixDQUFkO0FBQ0FGLGFBQU8sS0FBS0gsSUFBTCxDQUFVUyxNQUFWLENBQWlCRixLQUFqQixDQUFQLEVBQWdDQSxLQUFoQyxFQUF1Q0QsT0FBdkM7QUFDRDtBQUNGOztBQUVEVSxRQUFNWixNQUFOLEVBQXNCYSxHQUF0QixFQUF5RTtBQUN2RSxVQUFNLEVBQUNDLElBQUQsRUFBT0MsTUFBUCxLQUFpQixLQUFLbkIsSUFBTCxDQUFVZ0IsS0FBVixDQUFnQlIsTUFBTUosTUFBTixFQUFjYSxHQUFkLENBQWhCLENBQXZCO0FBQ0EsUUFBSSxDQUFDQyxJQUFMLEVBQVcsT0FBTyxFQUFQO0FBQ1gsV0FBTyxFQUFDWixTQUFTWSxLQUFLWixPQUFmLEVBQXdCYSxNQUF4QixFQUFQO0FBQ0Q7O0FBRUQsTUFBSUMsTUFBSixHQUFzQjtBQUNwQixVQUFNQSxTQUFTLElBQUlDLEdBQUosRUFBZjtBQUNBLFNBQUssTUFBTSxHQUFJVCxJQUFKLENBQVgsSUFBd0IsS0FBS1osSUFBTCxDQUFVYSxRQUFWLEVBQXhCLEVBQThDO0FBQzVDTyxhQUFPRSxHQUFQLENBQVcsZ0JBQU1SLE1BQU4sQ0FBYUYsSUFBYixDQUFYO0FBQ0Q7QUFDRCxXQUFPVyxNQUFNQyxJQUFOLENBQVdKLE1BQVgsQ0FBUDtBQUNEOztBQUVELE1BQUlLLFFBQUosR0FBeUI7QUFDdkIsVUFBTUEsV0FBVyxJQUFJSixHQUFKLEVBQWpCO0FBQ0EsU0FBSyxNQUFNLENBQUNILElBQUQsQ0FBWCxJQUFxQixLQUFLbEIsSUFBTCxDQUFVYSxRQUFWLEVBQXJCLEVBQTJDO0FBQ3pDLFVBQUlLLEtBQUtaLE9BQVQsRUFBa0JtQixTQUFTSCxHQUFULENBQWFKLEtBQUtaLE9BQWxCO0FBQ25CO0FBQ0QsV0FBT2lCLE1BQU1DLElBQU4sQ0FBV0MsUUFBWCxDQUFQO0FBQ0Q7O0FBRURDLFlBQWtCO0FBQ2hCLFVBQU1OLFNBQVMsS0FBS0EsTUFBTCxDQUFZTyxHQUFaLENBQWdCcEIsU0FBU0EsTUFBTW1CLE9BQU4sRUFBekIsQ0FBZjtBQUNBLFdBQU8sT0FBT04sT0FBT1EsSUFBUCxDQUFZLE9BQVosQ0FBUCxHQUE4QixJQUFyQztBQUNEO0FBNUN5QixDO2tCQUFQOUIsTTs7O0FBK0NyQixTQUFTSyxNQUFULENBQWdCZSxJQUFoQixFQUE0QlgsS0FBNUIsRUFBMENELE9BQTFDLEVBQTREO0FBQzFELE1BQUlZLEtBQUtXLElBQVQsRUFBZSxNQUFNLHNCQUFldEIsS0FBZixFQUFzQixnQkFBdEIsQ0FBTjtBQUNmVyxPQUFLVyxJQUFMLEdBQVksSUFBWjtBQUNBWCxPQUFLWixPQUFMLEdBQWVBLE9BQWY7QUFDRDs7QUFFRCxTQUFTRSxLQUFULENBQWVKLE1BQWYsRUFBK0JhLEdBQS9CLEVBQTRDO0FBQzFDO0FBQ0EsTUFBSUEsSUFBSSxDQUFKLE1BQVcsR0FBZixFQUFvQkEsTUFBTUEsSUFBSWEsS0FBSixDQUFVLENBQVYsQ0FBTjs7QUFFcEI7QUFDQWIsUUFBTUEsSUFBSWMsS0FBSixDQUFVLEdBQVYsRUFBZUMsS0FBZixFQUFOOztBQUVBO0FBQ0EsUUFBTUMsUUFBUWhCLElBQUljLEtBQUosQ0FBVSxHQUFWLEVBQWVHLE1BQWYsQ0FBc0JDLFFBQVFBLFNBQVMsRUFBdkMsQ0FBZDtBQUNBLFNBQU8sQ0FBQy9CLE9BQU9nQyxXQUFQLEVBQUQsRUFBdUJDLE1BQXZCLENBQThCSixLQUE5QixDQUFQO0FBQ0QiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuaW1wb3J0IFJvdXRlLCB7Um91dGVFcnJvcn0gZnJvbSBcIi4vcm91dGVcIlxuaW1wb3J0IFRyZWUgZnJvbSBcIi4vdHJlZVwiXG5pbXBvcnQgTm9kZSBmcm9tIFwiLi9ub2RlXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIHtcbiAgdHJlZTogVHJlZSA9IG5ldyBUcmVlXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKVxuICB9XG5cbiAgZGVmaW5lKG1ldGhvZDogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcsIGhhbmRsZXI6ID9PYmplY3QgPSBudWxsKSB7XG4gICAgY29uc3Qgcm91dGUgPSBSb3V0ZS5wYXJzZShtZXRob2QsIHBhdHRlcm4pXG4gICAgZGVmaW5lKHRoaXMudHJlZS5pbnNlcnQocm91dGUpLCByb3V0ZSwgaGFuZGxlcilcbiAgfVxuXG4gIG1vdW50KHBhdHRlcm46IHN0cmluZywgcm91dGVyOiBSb3V0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IFt7aGFuZGxlcn0sIHBhdGhdIG9mIHJvdXRlci50cmVlLnRyYXZlcnNlKCkpIHtcbiAgICAgIGNvbnN0IHJvdXRlID0gUm91dGUuY3JlYXRlKHBhdGgpLnByZWZpeChwYXR0ZXJuKVxuICAgICAgZGVmaW5lKHRoaXMudHJlZS5pbnNlcnQocm91dGUpLCByb3V0ZSwgaGFuZGxlcilcbiAgICB9XG4gIH1cblxuICBtYXRjaChtZXRob2Q6IHN0cmluZywgdXJsOiBzdHJpbmcpOiB7aGFuZGxlcj86ID9PYmplY3QsIHBhcmFtcz86IE9iamVjdH0ge1xuICAgIGNvbnN0IHtub2RlLCBwYXJhbXN9ID0gdGhpcy50cmVlLm1hdGNoKHBhcnNlKG1ldGhvZCwgdXJsKSlcbiAgICBpZiAoIW5vZGUpIHJldHVybiB7fVxuICAgIHJldHVybiB7aGFuZGxlcjogbm9kZS5oYW5kbGVyLCBwYXJhbXN9XG4gIH1cblxuICBnZXQgcm91dGVzKCk6IFJvdXRlW10ge1xuICAgIGNvbnN0IHJvdXRlcyA9IG5ldyBTZXRcbiAgICBmb3IgKGNvbnN0IFsgLCBwYXRoXSBvZiB0aGlzLnRyZWUudHJhdmVyc2UoKSkge1xuICAgICAgcm91dGVzLmFkZChSb3V0ZS5jcmVhdGUocGF0aCkpXG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHJvdXRlcylcbiAgfVxuXG4gIGdldCBoYW5kbGVycygpOiBPYmplY3RbXSB7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBuZXcgU2V0XG4gICAgZm9yIChjb25zdCBbbm9kZV0gb2YgdGhpcy50cmVlLnRyYXZlcnNlKCkpIHtcbiAgICAgIGlmIChub2RlLmhhbmRsZXIpIGhhbmRsZXJzLmFkZChub2RlLmhhbmRsZXIpXG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGhhbmRsZXJzKVxuICB9XG5cbiAgaW5zcGVjdCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJvdXRlcyA9IHRoaXMucm91dGVzLm1hcChyb3V0ZSA9PiByb3V0ZS5pbnNwZWN0KCkpXG4gICAgcmV0dXJuIFwiWyBcIiArIHJvdXRlcy5qb2luKFwiLFxcbiAgXCIpICsgXCIgXVwiXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lKG5vZGU6IE5vZGUsIHJvdXRlOiBSb3V0ZSwgaGFuZGxlcjogP09iamVjdCkge1xuICBpZiAobm9kZS5sZWFmKSB0aHJvdyBuZXcgUm91dGVFcnJvcihyb3V0ZSwgXCJhbHJlYWR5IGV4aXN0c1wiKVxuICBub2RlLmxlYWYgPSB0cnVlXG4gIG5vZGUuaGFuZGxlciA9IGhhbmRsZXJcbn1cblxuZnVuY3Rpb24gcGFyc2UobWV0aG9kOiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gIC8qIFJlbW92ZSBsZWFkaW5nIHNsYXNoLiAqL1xuICBpZiAodXJsWzBdID09PSBcIi9cIikgdXJsID0gdXJsLnNsaWNlKDEpXG5cbiAgLyogUmVtb3ZlIHF1ZXJ5IHN0cmluZy4gKi9cbiAgdXJsID0gdXJsLnNwbGl0KFwiP1wiKS5zaGlmdCgpXG5cbiAgLyogU3BsaXQgdXJsIGludG8gcGF0aCBzZWdtZW50cy4gKi9cbiAgY29uc3QgcGFydHMgPSB1cmwuc3BsaXQoXCIvXCIpLmZpbHRlcihwYXJ0ID0+IHBhcnQgIT09IFwiXCIpXG4gIHJldHVybiBbbWV0aG9kLnRvVXBwZXJDYXNlKCldLmNvbmNhdChwYXJ0cylcbn1cbiJdfQ==