"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ParseError = exports.RouteError = undefined;

var _node = require("./node");

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let RouteError = exports.RouteError = class RouteError extends Error {
  constructor(route, message) {
    super(`Route '${route.toString()}' ${message}`);

    Error.captureStackTrace(this, this.constructor);
    Object.freeze(this);
  }
};
let ParseError = exports.ParseError = class ParseError extends Error {
  constructor(pattern, message) {
    super(`Pattern '${pattern}' ${message}`);

    Error.captureStackTrace(this, this.constructor);
    Object.freeze(this);
  }
};
let Route = class Route {
  static parse(method, route) {
    method = method.toUpperCase();
    const parts = [new _node2.default(method)].concat(parse(route));
    return new Route(parts);
  }

  static create(path) {
    const parts = path.map(node => node.clone());
    return new Route(parts);
  }

  constructor(parts) {
    this.parts = parts;

    for (const part of this.parts) Object.freeze(part);
    Object.freeze(this);
  }

  prefix(prefix) {
    const path = this.parts.slice(1);
    const parts = [this.parts[0]].concat(parse(prefix)).concat(path);
    return new Route(parts);
  }

  get method() {
    return this.parts[0].toString();
  }

  get path() {
    return "/" + this.parts.slice(1).map(part => part.toString()).join("/");
  }

  inspect() {
    return this.toString();
  }

  toString() {
    return `${this.method} ${this.path}`;
  }
};
exports.default = Route;


function parse(route) {
  const nodes = [];
  const params = new Set();

  for (const part of route.split("/")) {
    if (!part.length) continue;

    let node;
    if (part[0] === "{" && part[part.length - 1] === "}") {
      const param = part.substring(1, part.length - 1);
      if (params.has(param)) {
        throw new ParseError(route, `has duplicate param {${param}}`);
      }

      params.add(param);
      node = new _node2.default(param, /.+/);
    } else {
      node = new _node2.default(part);
    }

    nodes.push(node);
  }

  return nodes;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yb3V0ZXIvcm91dGUuanMiXSwibmFtZXMiOlsiUm91dGVFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJyb3V0ZSIsIm1lc3NhZ2UiLCJ0b1N0cmluZyIsImNhcHR1cmVTdGFja1RyYWNlIiwiT2JqZWN0IiwiZnJlZXplIiwiUGFyc2VFcnJvciIsInBhdHRlcm4iLCJSb3V0ZSIsInBhcnNlIiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJwYXJ0cyIsIk5vZGUiLCJjb25jYXQiLCJjcmVhdGUiLCJwYXRoIiwibWFwIiwibm9kZSIsImNsb25lIiwicGFydCIsInByZWZpeCIsInNsaWNlIiwiam9pbiIsImluc3BlY3QiLCJub2RlcyIsInBhcmFtcyIsIlNldCIsInNwbGl0IiwibGVuZ3RoIiwicGFyYW0iLCJzdWJzdHJpbmciLCJoYXMiLCJhZGQiLCJwdXNoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7Ozs7OztJQUVhQSxVLFdBQUFBLFUsR0FBTixNQUFNQSxVQUFOLFNBQXlCQyxLQUF6QixDQUErQjtBQUNwQ0MsY0FBWUMsS0FBWixFQUEwQkMsT0FBMUIsRUFBMkM7QUFDekMsVUFBTyxVQUFTRCxNQUFNRSxRQUFOLEVBQWlCLEtBQUlELE9BQVEsRUFBN0M7O0FBRUFILFVBQU1LLGlCQUFOLENBQXdCLElBQXhCLEVBQThCLEtBQUtKLFdBQW5DO0FBQ0FLLFdBQU9DLE1BQVAsQ0FBYyxJQUFkO0FBQ0Q7QUFObUMsQztJQVN6QkMsVSxXQUFBQSxVLEdBQU4sTUFBTUEsVUFBTixTQUF5QlIsS0FBekIsQ0FBK0I7QUFDcENDLGNBQVlRLE9BQVosRUFBNkJOLE9BQTdCLEVBQThDO0FBQzVDLFVBQU8sWUFBV00sT0FBUSxLQUFJTixPQUFRLEVBQXRDOztBQUVBSCxVQUFNSyxpQkFBTixDQUF3QixJQUF4QixFQUE4QixLQUFLSixXQUFuQztBQUNBSyxXQUFPQyxNQUFQLENBQWMsSUFBZDtBQUNEO0FBTm1DLEM7SUFTakJHLEssR0FBTixNQUFN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dGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuaW1wb3J0IE5vZGUgZnJvbSBcIi4vbm9kZVwiXG5cbmV4cG9ydCBjbGFzcyBSb3V0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihyb3V0ZTogUm91dGUsIG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKGBSb3V0ZSAnJHtyb3V0ZS50b1N0cmluZygpfScgJHttZXNzYWdlfWApXG5cbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKVxuICAgIE9iamVjdC5mcmVlemUodGhpcylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGF0dGVybjogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihgUGF0dGVybiAnJHtwYXR0ZXJufScgJHttZXNzYWdlfWApXG5cbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKVxuICAgIE9iamVjdC5mcmVlemUodGhpcylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZSB7XG4gIHN0YXRpYyBwYXJzZShtZXRob2Q6IHN0cmluZywgcm91dGU6IHN0cmluZyk6IFJvdXRlIHtcbiAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIGNvbnN0IHBhcnRzID0gW25ldyBOb2RlKG1ldGhvZCldLmNvbmNhdChwYXJzZShyb3V0ZSkpXG4gICAgcmV0dXJuIG5ldyBSb3V0ZShwYXJ0cylcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUocGF0aDogTm9kZVtdKTogUm91dGUge1xuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5tYXAobm9kZSA9PiBub2RlLmNsb25lKCkpXG4gICAgcmV0dXJuIG5ldyBSb3V0ZShwYXJ0cylcbiAgfVxuXG4gIHBhcnRzOiBOb2RlW11cblxuICBjb25zdHJ1Y3RvcihwYXJ0czogTm9kZVtdKSB7XG4gICAgdGhpcy5wYXJ0cyA9IHBhcnRzXG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5wYXJ0cykgT2JqZWN0LmZyZWV6ZShwYXJ0KVxuICAgIE9iamVjdC5mcmVlemUodGhpcylcbiAgfVxuXG4gIHByZWZpeChwcmVmaXg6IHN0cmluZyk6IFJvdXRlIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5wYXJ0cy5zbGljZSgxKVxuICAgIGNvbnN0IHBhcnRzID0gW3RoaXMucGFydHNbMF1dLmNvbmNhdChwYXJzZShwcmVmaXgpKS5jb25jYXQocGF0aClcbiAgICByZXR1cm4gbmV3IFJvdXRlKHBhcnRzKVxuICB9XG5cbiAgZ2V0IG1ldGhvZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBhcnRzWzBdLnRvU3RyaW5nKClcbiAgfVxuXG4gIGdldCBwYXRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwiL1wiICsgdGhpcy5wYXJ0cy5zbGljZSgxKS5tYXAocGFydCA9PiBwYXJ0LnRvU3RyaW5nKCkpLmpvaW4oXCIvXCIpXG4gIH1cblxuICBpbnNwZWN0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5tZXRob2R9ICR7dGhpcy5wYXRofWBcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZShyb3V0ZTogc3RyaW5nKSB7XG4gIGNvbnN0IG5vZGVzOiBOb2RlW10gPSBbXVxuICBjb25zdCBwYXJhbXMgPSBuZXcgU2V0XG5cbiAgZm9yIChjb25zdCBwYXJ0IG9mIHJvdXRlLnNwbGl0KFwiL1wiKSkge1xuICAgIGlmICghcGFydC5sZW5ndGgpIGNvbnRpbnVlXG5cbiAgICBsZXQgbm9kZTogTm9kZVxuICAgIGlmIChwYXJ0WzBdID09PSBcIntcIiAmJiBwYXJ0W3BhcnQubGVuZ3RoIC0gMV0gPT09IFwifVwiKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHBhcnQuc3Vic3RyaW5nKDEsIHBhcnQubGVuZ3RoIC0gMSlcbiAgICAgIGlmIChwYXJhbXMuaGFzKHBhcmFtKSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihyb3V0ZSwgYGhhcyBkdXBsaWNhdGUgcGFyYW0geyR7cGFyYW19fWApXG4gICAgICB9XG5cbiAgICAgIHBhcmFtcy5hZGQocGFyYW0pXG4gICAgICBub2RlID0gbmV3IE5vZGUocGFyYW0sIC8uKy8pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZShwYXJ0KVxuICAgIH1cblxuICAgIG5vZGVzLnB1c2gobm9kZSlcbiAgfVxuXG4gIHJldHVybiBub2Rlc1xufVxuIl19