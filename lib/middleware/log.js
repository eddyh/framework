"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = log;

var _http = require("http");

var _http2 = _interopRequireDefault(_http);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const statusCodes = new Map();
/* eslint-disable dot-notation */
/* eslint-disable no-unused-expressions */

for (const code in _http2.default.STATUS_CODES) {
  const number = parseInt(code);
  statusCodes.set(number, _http2.default.STATUS_CODES[number].toLowerCase());
}

function log(logger) {
  return function log(next) {
    this;

    const socket = this.request.socket;

    /* Check what has been previously recorded as read/written on this socket.
       The request may not be the first over this socket. */
    const bytesReadPreviously = socket.bytesReadPreviously || 0;
    const bytesWrittenPreviously = socket.bytesWrittenPreviously || 0;

    const startTime = process.hrtime();

    this.data.log = Object.create(null);

    this.response.on("finish", () => {
      /* Store current read/written count for future reference. */
      socket.bytesReadPreviously = socket.bytesRead;
      socket.bytesWrittenPreviously = socket.bytesWritten;

      const requestMethod = this.method;
      const requestUrl = this.url;
      const requestSize = socket.bytesRead - bytesReadPreviously;

      const status = this.response.statusCode;
      const responseSize = socket.bytesWritten - bytesWrittenPreviously;

      const userAgent = this.get("user-agent");
      const referer = this.get("referer");

      const [sec, nano] = process.hrtime(startTime);
      const latency = `${(sec + 1e-9 * nano).toFixed(3)}s`;

      let remoteIp = socket.remoteAddress;
      const forwarded = this.get("x-forwarded-for");
      if (forwarded) {
        remoteIp = forwarded.split(",").shift();
      }

      const httpRequest = {
        requestMethod,
        requestUrl,
        requestSize,
        status,
        responseSize,
        userAgent,
        remoteIp,
        referer,
        latency
        // protocol, TODO
      };

      const logContext = Object.assign({}, this.data.log, { httpRequest });

      if (status >= 500 && this.data.error) {
        /* An error was thrown somewhere. */
        if (this.data.error.expose) {
          /* This error is exposable, so it is to be expected. */
          logger.warning(this.data.error.message || "(no message)", logContext);
        } else {
          /* This was an internal error, not supposed to be exposed. Log the
             entire stack trace so we can debug later. */
          logger.error(this.data.error.stack || this.data.error.toString(), logContext);
        }
      } else {
        /* No error was thrown, or error was in 4xx range. */
        if (isHealthCheck(httpRequest)) {
          logger.debug(statusCodes.get(status), logContext);
        } else {
          logger.info(statusCodes.get(status), logContext);
        }
      }
    });

    return next();
  };
}

const healthCheckTokens = new Set(["GoogleHC", "ELB-HealthChecker", "kube-probe"]);

function isHealthCheck({ userAgent }) {
  if (!userAgent) return false;
  return healthCheckTokens.has(userAgent.split("/")[0]);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9taWRkbGV3YXJlL2xvZy5qcyJdLCJuYW1lcyI6WyJsb2ciLCJzdGF0dXNDb2RlcyIsIk1hcCIsImNvZGUiLCJTVEFUVVNfQ09ERVMiLCJudW1iZXIiLCJwYXJzZUludCIsInNldCIsInRvTG93ZXJDYXNlIiwibG9nZ2VyIiwibmV4dCIsInNvY2tldCIsInJlcXVlc3QiLCJieXRlc1JlYWRQcmV2aW91c2x5IiwiYnl0ZXNXcml0dGVuUHJldmlvdXNseSIsInN0YXJ0VGltZSIsInByb2Nlc3MiLCJocnRpbWUiLCJkYXRhIiwiT2JqZWN0IiwiY3JlYXRlIiwicmVzcG9uc2UiLCJvbiIsImJ5dGVzUmVhZCIsImJ5dGVzV3JpdHRlbiIsInJlcXVlc3RNZXRob2QiLCJtZXRob2QiLCJyZXF1ZXN0VXJsIiwidXJsIiwicmVxdWVzdFNpemUiLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwicmVzcG9uc2VTaXplIiwidXNlckFnZW50IiwiZ2V0IiwicmVmZXJlciIsInNlYyIsIm5hbm8iLCJsYXRlbmN5IiwidG9GaXhlZCIsInJlbW90ZUlwIiwicmVtb3RlQWRkcmVzcyIsImZvcndhcmRlZCIsInNwbGl0Iiwic2hpZnQiLCJodHRwUmVxdWVzdCIsImxvZ0NvbnRleHQiLCJhc3NpZ24iLCJlcnJvciIsImV4cG9zZSIsIndhcm5pbmciLCJtZXNzYWdlIiwic3RhY2siLCJ0b1N0cmluZyIsImlzSGVhbHRoQ2hlY2siLCJkZWJ1ZyIsImluZm8iLCJoZWFsdGhDaGVja1Rva2VucyIsIlNldCIsImhhcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBbUJ3QkEsRzs7QUFoQnhCOzs7Ozs7QUFVQSxNQUFNQyxjQUFtQyxJQUFJQyxHQUFKLEVBQXpDO0FBWkE7QUFDQTs7QUFZQSxLQUFLLE1BQU1DLElBQVgsSUFBbUIsZUFBS0MsWUFBeEIsRUFBc0M7QUFDcEMsUUFBTUMsU0FBU0MsU0FBU0gsSUFBVCxDQUFmO0FBQ0FGLGNBQVlNLEdBQVosQ0FBZ0JGLE1BQWhCLEVBQXdC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QWIsRUFBc0NnQixVQUF0QztBQUNELFNBRkQsTUFFTztBQUNMckMsaUJBQU8rQyxJQUFQLENBQVl2RCxZQUFZaUMsR0FBWixDQUFnQkosTUFBaEIsQ0FBWixFQUFxQ2dCLFVBQXJDO0FBQ0Q7QUFDRjtBQUNGLEtBekREOztBQTJEQSxXQUFPcEMsTUFBUDtBQUNELEdBMUVEO0FBMkVEOztBQUVELE1BQU0rQyxvQkFBb0IsSUFBSUMsR0FBSixDQUFRLENBQ2hDLFVBRGdDLEVBRWhDLG1CQUZnQyxFQUdoQyxZQUhnQyxDQUFSLENBQTFCOztBQU1BLFNBQVNKLGFBQVQsQ0FBdUIsRUFBQ3JCLFNBQUQsRUFBdkIsRUFBaUQ7QUFDL0MsTUFBSSxDQUFDQSxTQUFMLEVBQWdCLE9BQU8sS0FBUDtBQUNoQixTQUFPd0Isa0JBQWtCRSxHQUFsQixDQUFzQjFCLFVBQVVVLEtBQVYsQ0FBZ0IsR0FBaEIsRUFBcUIsQ0FBckIsQ0FBdEIsQ0FBUDtBQUNEIiwiZmlsZSI6ImxvZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBkb3Qtbm90YXRpb24gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuaW1wb3J0IGh0dHAgZnJvbSBcImh0dHBcIlxuXG5pbXBvcnQgdHlwZSB7Q29udGV4dCwgTmV4dCwgTWlkZGxld2FyZX0gZnJvbSBcIi4uL21pZGRsZXdhcmVcIlxuaW1wb3J0IHR5cGUge0h0dHBSZXF1ZXN0LCBMb2dDb250ZXh0LCBMb2dnZXJ9IGZyb20gXCIuLi91dGlsL2xvZ2dlclwiXG5cbnR5cGUgU3RhdHNTb2NrZXQgPSBuZXQkU29ja2V0ICYge1xuICBieXRlc1JlYWRQcmV2aW91c2x5PzogbnVtYmVyLFxuICBieXRlc1dyaXR0ZW5QcmV2aW91c2x5PzogbnVtYmVyLFxufVxuXG5jb25zdCBzdGF0dXNDb2RlczogTWFwPG51bWJlciwgc3RyaW5nPiA9IG5ldyBNYXBcbmZvciAoY29uc3QgY29kZSBpbiBodHRwLlNUQVRVU19DT0RFUykge1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludChjb2RlKVxuICBzdGF0dXNDb2Rlcy5zZXQobnVtYmVyLCBodHRwLlNUQVRVU19DT0RFU1tudW1iZXJdLnRvTG93ZXJDYXNlKCkpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZyhsb2dnZXI6IExvZ2dlcik6IE1pZGRsZXdhcmUge1xuICByZXR1cm4gZnVuY3Rpb24gbG9nKG5leHQ6IE5leHQpIHtcbiAgICAodGhpczogQ29udGV4dClcblxuICAgIGNvbnN0IHNvY2tldDogU3RhdHNTb2NrZXQgPSB0aGlzLnJlcXVlc3Quc29ja2V0XG5cbiAgICAvKiBDaGVjayB3aGF0IGhhcyBiZWVuIHByZXZpb3VzbHkgcmVjb3JkZWQgYXMgcmVhZC93cml0dGVuIG9uIHRoaXMgc29ja2V0LlxuICAgICAgIFRoZSByZXF1ZXN0IG1heSBub3QgYmUgdGhlIGZpcnN0IG92ZXIgdGhpcyBzb2NrZXQuICovXG4gICAgY29uc3QgYnl0ZXNSZWFkUHJldmlvdXNseSA9IHNvY2tldC5ieXRlc1JlYWRQcmV2aW91c2x5IHx8IDBcbiAgICBjb25zdCBieXRlc1dyaXR0ZW5QcmV2aW91c2x5ID0gc29ja2V0LmJ5dGVzV3JpdHRlblByZXZpb3VzbHkgfHwgMFxuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcHJvY2Vzcy5ocnRpbWUoKVxuXG4gICAgdGhpcy5kYXRhLmxvZyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIHRoaXMucmVzcG9uc2Uub24oXCJmaW5pc2hcIiwgKCkgPT4ge1xuICAgICAgLyogU3RvcmUgY3VycmVudCByZWFkL3dyaXR0ZW4gY291bnQgZm9yIGZ1dHVyZSByZWZlcmVuY2UuICovXG4gICAgICBzb2NrZXQuYnl0ZXNSZWFkUHJldmlvdXNseSA9IHNvY2tldC5ieXRlc1JlYWRcbiAgICAgIHNvY2tldC5ieXRlc1dyaXR0ZW5QcmV2aW91c2x5ID0gc29ja2V0LmJ5dGVzV3JpdHRlblxuXG4gICAgICBjb25zdCByZXF1ZXN0TWV0aG9kID0gdGhpcy5tZXRob2RcbiAgICAgIGNvbnN0IHJlcXVlc3RVcmwgPSB0aGlzLnVybFxuICAgICAgY29uc3QgcmVxdWVzdFNpemUgPSBzb2NrZXQuYnl0ZXNSZWFkIC0gYnl0ZXNSZWFkUHJldmlvdXNseVxuXG4gICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLnJlc3BvbnNlLnN0YXR1c0NvZGVcbiAgICAgIGNvbnN0IHJlc3BvbnNlU2l6ZSA9IHNvY2tldC5ieXRlc1dyaXR0ZW4gLSBieXRlc1dyaXR0ZW5QcmV2aW91c2x5XG5cbiAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IHRoaXMuZ2V0KFwidXNlci1hZ2VudFwiKVxuICAgICAgY29uc3QgcmVmZXJlciA9IHRoaXMuZ2V0KFwicmVmZXJlclwiKVxuXG4gICAgICBjb25zdCBbc2VjLCBuYW5vXSA9IHByb2Nlc3MuaHJ0aW1lKHN0YXJ0VGltZSlcbiAgICAgIGNvbnN0IGxhdGVuY3kgPSBgJHsoc2VjICsgMWUtOSAqIG5hbm8pLnRvRml4ZWQoMyl9c2BcblxuICAgICAgbGV0IHJlbW90ZUlwID0gc29ja2V0LnJlbW90ZUFkZHJlc3NcbiAgICAgIGNvbnN0IGZvcndhcmRlZCA9IHRoaXMuZ2V0KFwieC1mb3J3YXJkZWQtZm9yXCIpXG4gICAgICBpZiAoZm9yd2FyZGVkKSB7XG4gICAgICAgIHJlbW90ZUlwID0gZm9yd2FyZGVkLnNwbGl0KFwiLFwiKS5zaGlmdCgpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGh0dHBSZXF1ZXN0OiBIdHRwUmVxdWVzdCA9IHtcbiAgICAgICAgcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgcmVxdWVzdFVybCxcbiAgICAgICAgcmVxdWVzdFNpemUsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VTaXplLFxuICAgICAgICB1c2VyQWdlbnQsXG4gICAgICAgIHJlbW90ZUlwLFxuICAgICAgICByZWZlcmVyLFxuICAgICAgICBsYXRlbmN5LFxuICAgICAgICAvLyBwcm90b2NvbCwgVE9ET1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2dDb250ZXh0OiBMb2dDb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kYXRhLmxvZywge2h0dHBSZXF1ZXN0fSlcblxuICAgICAgaWYgKHN0YXR1cyA+PSA1MDAgJiYgdGhpcy5kYXRhLmVycm9yKSB7XG4gICAgICAgIC8qIEFuIGVycm9yIHdhcyB0aHJvd24gc29tZXdoZXJlLiAqL1xuICAgICAgICBpZiAodGhpcy5kYXRhLmVycm9yLmV4cG9zZSkge1xuICAgICAgICAgIC8qIFRoaXMgZXJyb3IgaXMgZXhwb3NhYmxlLCBzbyBpdCBpcyB0byBiZSBleHBlY3RlZC4gKi9cbiAgICAgICAgICBsb2dnZXIud2FybmluZyh0aGlzLmRhdGEuZXJyb3IubWVzc2FnZSB8fCBcIihubyBtZXNzYWdlKVwiLCBsb2dDb250ZXh0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIFRoaXMgd2FzIGFuIGludGVybmFsIGVycm9yLCBub3Qgc3VwcG9zZWQgdG8gYmUgZXhwb3NlZC4gTG9nIHRoZVxuICAgICAgICAgICAgIGVudGlyZSBzdGFjayB0cmFjZSBzbyB3ZSBjYW4gZGVidWcgbGF0ZXIuICovXG4gICAgICAgICAgbG9nZ2VyLmVycm9yKHRoaXMuZGF0YS5lcnJvci5zdGFjayB8fCB0aGlzLmRhdGEuZXJyb3IudG9TdHJpbmcoKSwgbG9nQ29udGV4dClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogTm8gZXJyb3Igd2FzIHRocm93biwgb3IgZXJyb3Igd2FzIGluIDR4eCByYW5nZS4gKi9cbiAgICAgICAgaWYgKGlzSGVhbHRoQ2hlY2soaHR0cFJlcXVlc3QpKSB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKHN0YXR1c0NvZGVzLmdldChzdGF0dXMpLCBsb2dDb250ZXh0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKHN0YXR1c0NvZGVzLmdldChzdGF0dXMpLCBsb2dDb250ZXh0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBuZXh0KClcbiAgfVxufVxuXG5jb25zdCBoZWFsdGhDaGVja1Rva2VucyA9IG5ldyBTZXQoW1xuICBcIkdvb2dsZUhDXCIsXG4gIFwiRUxCLUhlYWx0aENoZWNrZXJcIixcbiAgXCJrdWJlLXByb2JlXCIsXG5dKVxuXG5mdW5jdGlvbiBpc0hlYWx0aENoZWNrKHt1c2VyQWdlbnR9OiBIdHRwUmVxdWVzdCkge1xuICBpZiAoIXVzZXJBZ2VudCkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBoZWFsdGhDaGVja1Rva2Vucy5oYXModXNlckFnZW50LnNwbGl0KFwiL1wiKVswXSlcbn1cbiJdfQ==