"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = allowCors;

/* eslint-disable no-unused-expressions */

function allowCors(options = {}) {
  const allowAll = !options.origins;
  const allowedOrigins = new Set(options.origins);

  const allowedMethodList = (options.methods || ["GET", "POST", "PUT", "PATCH", "DELETE"]).join(", ");
  const requestHeaderList = (options.requestHeaders || []).join(", ");
  const responseHeaderList = (options.responseHeaders || []).join(", ");
  const allowCredentials = options.allowCredentials;
  const maxAge = options.maxAge;

  return function cors(next) {
    this;

    const origin = this.get("origin");

    /* Avoid cache conflicts if the response headers can be different
       depending on the Origin header. Since we don't include CORS headers
       for requests without an Origin request header this must always be set. */
    this.set("Vary", "Origin");

    if (origin) {
      /* This is a cross origin request. Test if the origin is allowed. */
      if (allowAll || allowedOrigins.has(origin)) {
        /* Only set the returned origin header that has been requested to avoid
           disclosing the entire list of configured origins. */
        this.set("Access-Control-Allow-Origin", allowAll ? "*" : origin);
      } else {
        /* Origin is disallowed. The origin is not included in the list, so
           we stop here without returning CORS headers. */
        this.status = 403;
        return Promise.resolve();
      }

      this.set("Access-Control-Allow-Methods", allowedMethodList);
      if (requestHeaderList) this.set("Access-Control-Allow-Headers", requestHeaderList);
      if (responseHeaderList) this.set("Access-Control-Expose-Headers", responseHeaderList);
      if (allowCredentials) this.set("Access-Control-Allow-Credentials", "true");
      if (maxAge) this.set("Access-Control-Max-Age", maxAge);

      if (this.method === "OPTIONS" && this.get("access-control-request-method")) {
        /* Return early if this is a preflight request. */
        this.status = 200;
        return Promise.resolve();
      }
    }

    return next();
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9taWRkbGV3YXJlL2FsbG93LWNvcnMuanMiXSwibmFtZXMiOlsiYWxsb3dDb3JzIiwib3B0aW9ucyIsImFsbG93QWxsIiwib3JpZ2lucyIsImFsbG93ZWRPcmlnaW5zIiwiU2V0IiwiYWxsb3dlZE1ldGhvZExpc3QiLCJtZXRob2RzIiwiam9pbiIsInJlcXVlc3RIZWFkZXJMaXN0IiwicmVxdWVzdEhlYWRlcnMiLCJyZXNwb25zZUhlYWRlckxpc3QiLCJyZXNwb25zZUhlYWRlcnMiLCJhbGxvd0NyZWRlbnRpYWxzIiwibWF4QWdlIiwiY29ycyIsIm5leHQiLCJvcmlnaW4iLCJnZXQiLCJzZXQiLCJoYXMiLCJzdGF0dXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1ldGhvZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBY3dCQSxTOztBQWJ4Qjs7QUFhZSxTQUFTQSxTQUFULENBQW1CQyxVQUE0QixFQUEvQyxFQUErRDtBQUM1RSxRQUFNQyxXQUFXLENBQUNELFFBQVFFLE9BQTFCO0FBQ0EsUUFBTUMsaUJBQWlCLElBQUlDLEdBQUosQ0FBUUosUUFBUUUsT0FBaEIsQ0FBdkI7O0FBRUEsUUFBTUcsb0JBQW9CLENBQUNMLFFBQVFNLE9BQVIsSUFBbUIsQ0FBQyxLQUFELEVBQVEsTUFBUixFQUFnQixLQUFoQixFQUF1QixPQUF2QixFQUFnQyxRQUFoQyxDQUFwQixFQUErREMsSUFBL0QsQ0FBb0UsSUFBcEUsQ0FBMUI7QUFDQSxRQUFNQyxvQkFBb0IsQ0FBQ1IsUUFBUVMsY0FBUixJQUEwQixFQUEzQixFQUErQkYsSUFBL0IsQ0FBb0MsSUFBcEMsQ0FBMUI7QUFDQSxRQUFNRyxxQkFBcUIsQ0FBQ1YsUUFBUVcsZUFBUixJQUEyQixFQUE1QixFQUFnQ0osSUFBaEMsQ0FBcUMsSUFBckMsQ0FBM0I7QUFDQSxRQUFNSyxtQkFBbUJaLFFBQVFZLGdCQUFqQztBQUNBLFFBQU1DLFNBQVNiLFFBQVFhLE1BQXZCOztBQUVBLFNBQU8sU0FBU0MsSUFBVCxDQUFjQyxJQUFkLEVBQTBCO0FBQzlCLFFBQUQ7O0FBRUEsVUFBTUMsU0FBUyxLQUFLQyxHQUFMLENBQVMsUUFBVCxDQUFmOztBQUVBOzs7QUFHQSxTQUFLQyxHQUFMLENBQVMsTUFBVCxFQUFpQixRQUFqQjs7QUFFQSxRQUFJRixNQUFKLEVBQVk7QUFDVjtBQUNBLFVBQUlmLFlBQVlFLGVBQWVnQixHQUFmLENBQW1CSCxNQUFuQixDQUFoQixFQUE0QztBQUMxQzs7QUFFQSxhQUFLRSxHQUFMLENBQVMsNkJBQVQsRUFBd0NqQixXQUFXLEdBQVgsR0FBaUJlLE1BQXpEO0FBQ0QsT0FKRCxNQUlPO0FBQ0w7O0FBRUEsYUFBS0ksTUFBTCxHQUFjLEdBQWQ7QUFDQSxlQUFPQyxRQUFRQyxPQUFSLEVBQVA7QUFDRDs7QUFFRCxXQUFLSixHQUFMLENBQVMsOEJBQVQsRUFBeUNiLGlCQUF6QztBQUNBLFVBQUlHLGlCQUFKLEVBQXVCLEtBQUtVLEdBQUwsQ0FBUyw4QkFBVCxFQUF5Q1YsaUJBQXpDO0FBQ3ZCLFVBQUlFLGtCQUFKLEVBQXdCLEtBQUtRLEdBQUwsQ0FBUywrQkFBVCxFQUEwQ1Isa0JBQTFDO0FBQ3hCLFVBQUlFLGdCQUFKLEVBQXNCLEtBQUtNLEdBQUwsQ0FBUyxrQ0FBVCxFQUE2QyxNQUE3QztBQUN0QixVQUFJTCxNQUFKLEVBQVksS0FBS0ssR0FBTCxDQUFTLHdCQUFULEVBQW1DTCxNQUFuQzs7QUFFWixVQUFJLEtBQUtVLE1BQUwsS0FBZ0IsU0FBaEIsSUFBNkIsS0FBS04sR0FBTCxDQUFTLCtCQUFULENBQWpDLEVBQTRFO0FBQzFFO0FBQ0EsYUFBS0csTUFBTCxHQUFjLEdBQWQ7QUFDQSxlQUFPQyxRQUFRQyxPQUFSLEVBQVA7QUFDRDtBQUNGOztBQUVELFdBQU9QLE1BQVA7QUFDRCxHQXJDRDtBQXNDRCIsImZpbGUiOiJhbGxvdy1jb3JzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuXG5pbXBvcnQgdHlwZSB7Q29udGV4dCwgTmV4dCwgTWlkZGxld2FyZX0gZnJvbSBcIi4uL21pZGRsZXdhcmVcIlxuXG50eXBlIEFsbG93Q29yc09wdGlvbnMgPSB7XG4gIG9yaWdpbnM/OiBBcnJheTxzdHJpbmc+LFxuICBtZXRob2RzPzogQXJyYXk8c3RyaW5nPixcbiAgcmVxdWVzdEhlYWRlcnM/OiBBcnJheTxzdHJpbmc+LFxuICByZXNwb25zZUhlYWRlcnM/OiBBcnJheTxzdHJpbmc+LFxuICBhbGxvd0NyZWRlbnRpYWxzPzogYm9vbGVhbixcbiAgbWF4QWdlPzogbnVtYmVyLFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhbGxvd0NvcnMob3B0aW9uczogQWxsb3dDb3JzT3B0aW9ucyA9IHt9KTogTWlkZGxld2FyZSB7XG4gIGNvbnN0IGFsbG93QWxsID0gIW9wdGlvbnMub3JpZ2luc1xuICBjb25zdCBhbGxvd2VkT3JpZ2lucyA9IG5ldyBTZXQob3B0aW9ucy5vcmlnaW5zKVxuXG4gIGNvbnN0IGFsbG93ZWRNZXRob2RMaXN0ID0gKG9wdGlvbnMubWV0aG9kcyB8fCBbXCJHRVRcIiwgXCJQT1NUXCIsIFwiUFVUXCIsIFwiUEFUQ0hcIiwgXCJERUxFVEVcIl0pLmpvaW4oXCIsIFwiKVxuICBjb25zdCByZXF1ZXN0SGVhZGVyTGlzdCA9IChvcHRpb25zLnJlcXVlc3RIZWFkZXJzIHx8IFtdKS5qb2luKFwiLCBcIilcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJMaXN0ID0gKG9wdGlvbnMucmVzcG9uc2VIZWFkZXJzIHx8IFtdKS5qb2luKFwiLCBcIilcbiAgY29uc3QgYWxsb3dDcmVkZW50aWFscyA9IG9wdGlvbnMuYWxsb3dDcmVkZW50aWFsc1xuICBjb25zdCBtYXhBZ2UgPSBvcHRpb25zLm1heEFnZVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb3JzKG5leHQ6IE5leHQpIHtcbiAgICAodGhpczogQ29udGV4dClcblxuICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0KFwib3JpZ2luXCIpXG5cbiAgICAvKiBBdm9pZCBjYWNoZSBjb25mbGljdHMgaWYgdGhlIHJlc3BvbnNlIGhlYWRlcnMgY2FuIGJlIGRpZmZlcmVudFxuICAgICAgIGRlcGVuZGluZyBvbiB0aGUgT3JpZ2luIGhlYWRlci4gU2luY2Ugd2UgZG9uJ3QgaW5jbHVkZSBDT1JTIGhlYWRlcnNcbiAgICAgICBmb3IgcmVxdWVzdHMgd2l0aG91dCBhbiBPcmlnaW4gcmVxdWVzdCBoZWFkZXIgdGhpcyBtdXN0IGFsd2F5cyBiZSBzZXQuICovXG4gICAgdGhpcy5zZXQoXCJWYXJ5XCIsIFwiT3JpZ2luXCIpXG5cbiAgICBpZiAob3JpZ2luKSB7XG4gICAgICAvKiBUaGlzIGlzIGEgY3Jvc3Mgb3JpZ2luIHJlcXVlc3QuIFRlc3QgaWYgdGhlIG9yaWdpbiBpcyBhbGxvd2VkLiAqL1xuICAgICAgaWYgKGFsbG93QWxsIHx8IGFsbG93ZWRPcmlnaW5zLmhhcyhvcmlnaW4pKSB7XG4gICAgICAgIC8qIE9ubHkgc2V0IHRoZSByZXR1cm5lZCBvcmlnaW4gaGVhZGVyIHRoYXQgaGFzIGJlZW4gcmVxdWVzdGVkIHRvIGF2b2lkXG4gICAgICAgICAgIGRpc2Nsb3NpbmcgdGhlIGVudGlyZSBsaXN0IG9mIGNvbmZpZ3VyZWQgb3JpZ2lucy4gKi9cbiAgICAgICAgdGhpcy5zZXQoXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiwgYWxsb3dBbGwgPyBcIipcIiA6IG9yaWdpbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIE9yaWdpbiBpcyBkaXNhbGxvd2VkLiBUaGUgb3JpZ2luIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgbGlzdCwgc29cbiAgICAgICAgICAgd2Ugc3RvcCBoZXJlIHdpdGhvdXQgcmV0dXJuaW5nIENPUlMgaGVhZGVycy4gKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSA0MDNcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kc1wiLCBhbGxvd2VkTWV0aG9kTGlzdClcbiAgICAgIGlmIChyZXF1ZXN0SGVhZGVyTGlzdCkgdGhpcy5zZXQoXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzXCIsIHJlcXVlc3RIZWFkZXJMaXN0KVxuICAgICAgaWYgKHJlc3BvbnNlSGVhZGVyTGlzdCkgdGhpcy5zZXQoXCJBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVyc1wiLCByZXNwb25zZUhlYWRlckxpc3QpXG4gICAgICBpZiAoYWxsb3dDcmVkZW50aWFscykgdGhpcy5zZXQoXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiLCBcInRydWVcIilcbiAgICAgIGlmIChtYXhBZ2UpIHRoaXMuc2V0KFwiQWNjZXNzLUNvbnRyb2wtTWF4LUFnZVwiLCBtYXhBZ2UpXG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJPUFRJT05TXCIgJiYgdGhpcy5nZXQoXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiKSkge1xuICAgICAgICAvKiBSZXR1cm4gZWFybHkgaWYgdGhpcyBpcyBhIHByZWZsaWdodCByZXF1ZXN0LiAqL1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDIwMFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dCgpXG4gIH1cbn1cbiJdfQ==